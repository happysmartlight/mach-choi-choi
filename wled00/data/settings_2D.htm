<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
	<title>2D Set-up</title>
	<style> html { visibility: hidden; } </style> <!-- prevent white & ugly display while loading, unhidden in loadResources() -->
	<script>
	var maxPanels=64;
	var ctx = null;
	function fS(){d.Sf.submit();} // <button type=submit> sometimes didn't work
	// load common.js with retry on error
	(function loadFiles() {
		const l = document.createElement('script');
		l.src = 'common.js';
		l.onload = () => loadResources(['style.css'], S); // load style.css then call S()
		l.onerror = () => setTimeout(loadFiles, 100);
		document.head.appendChild(l);
	})();

	function S() {
		getLoc();
		loadJS(getURL('/settings/s.js?p=10'), false, undefined, ()=>{
			UI();
			Sf.MPC.setAttribute("max",maxPanels);
		});	// If we set async false, file is loaded and executed, then next statement is processed
		if (loc) d.Sf.action = getURL('/settings/2D');
	}

	function UI() {
		if (gId("somp").value === "0") {
			gId("mpdiv").style.display = "none";
			resetPanels();
			return;
		}
		gId("mpdiv").style.display = "block";
		draw();
	}

	function addPanels() {
		let c = parseInt(d.Sf.MPC.value);
		let i = gId("panels").children.length;
		if (i<c) for (let j=i; j<c; j++) addPanel(j);
		if (i>c) for (let j=i; j>c; j--) remPanel();
	}

	function addPanel(i=0) {
		let p = gId("panels");
		if (p.children.length >= maxPanels) return;
		var pw = parseInt(d.Sf.PW.value);
		var ph = parseInt(d.Sf.PH.value);
		let b = `<div id="pnl${i}"><hr class="sml">Bảng ${i}<br>
LED đầu tiên: <select name="P${i}B" oninput="UI()">
	<option value="0">Trên</option>
	<option value="1">Dưới</option>
</select><select name="P${i}R" oninput="UI()">
	<option value="0">Trái</option>
	<option value="1">Phải</option>
</select><br>
Hướng: <select name="P${i}V" oninput="UI()">
	<option value="0">Ngang</option>
	<option value="1">Dọc</option>
</select><br>
Dạng rắn rít: <input type="checkbox" name="P${i}S" oninput="UI()"><br>
Kích thước (Rộng x Cao): <input name="P${i}W" type="number" min="1" max="255" value="${pw}" oninput="UI()"> x <input name="P${i}H" type="number" min="1" max="255" value="${ph}" oninput="UI()"><br>
Dịch X: <input name="P${i}X" type="number" min="0" max="255" value="0" oninput="UI()">
Y: <input name="P${i}Y" type="number" min="0" max="255" value="0" oninput="UI()"><br><i>(dịch từ góc trên bên trái theo số LED)</i>
</div>`;
		p.insertAdjacentHTML("beforeend", b);
	}

	function remPanel() {
		let p = gId("panels").children;
	  	var i = p.length;
	  	if (i <= 1) return;
	  	p[i-1].remove();
	}

	function resetPanels() {
		d.Sf.MPC.value = 1;
		let e = gId("panels").children
		for (let i = e.length; i>0; i--) e[i-1].remove();
	}
/*
	function btnPanel(i) {
		gId("pnl_add").style.display = (i<maxPanels) ? "inline":"none";
		gId("pnl_rem").style.display = (i>1) ? "inline":"none";
	}
*/
	function gen() {
		resetPanels();

		var pansH = parseInt(Sf.MPH.value);
		var pansV = parseInt(Sf.MPV.value);
		var c = pansH*pansV;
		Sf.MPC.value = c; // number of panels

		var ps = Sf.PS.checked;
		var pv = Sf.PV.value==="1";
		var pb = Sf.PB.value==="1";
		var pr = Sf.PR.value==="1";
		var pw = parseInt(Sf.PW.value);
		var ph = parseInt(Sf.PH.value);

		var h = pv ? pansV : pansH;
		var v = pv ? pansH : pansV;
		for (let j = 0, p = 0; j < v; j++) {
			for (let i = 0; i < h; i++, p++) {
				if (j*i < maxPanels) addPanel(p);
				var y = (pv?pr:pb) ? v-j-1: j;
				var x = (pv?pb:pr) ? h-i-1 : i;
				x = ps && j%2 ? h-x-1 : x;
				Sf[`P${p}X`].value = (pv?y:x) * pw;
				Sf[`P${p}Y`].value = (pv?x:y) * ph
				Sf[`P${p}W`].value = pw;
				Sf[`P${p}H`].value = ph;
			}
		}
		UI(); // Update the preview after generating panels
	}

	function expand(o,i)
	{
		i.style.display = i.style.display!=="none" ? "none" : "";
		o.style.rotate = i.style.display==="none" ? "none" : "90deg";
	}

	function draw() {

		if (!ctx) {
			//WLEDMM: add canvas, initialize and set UI
			var canvas = gId("canvas");
			canvas.width  = window.innerWidth > 640?640:400; //Mobile gets 400, pc 640
			canvas.height = canvas.width;
			ctx = canvas.getContext('2d');

			// window.requestAnimationFrame(animate);
		}

		//calc max height and width
		var maxWidth = 0;
		var maxHeight = 0;
		for (let p=0; p<gId("panels").children.length; p++) {
			var px = parseInt(Sf[`P${p}X`].value); //first led x
			var py = parseInt(Sf[`P${p}Y`].value); //first led y
			var pw = parseInt(Sf[`P${p}W`].value); //width
			var ph = parseInt(Sf[`P${p}H`].value); //height
			maxWidth = Math.max(maxWidth, px + pw);
			maxHeight = Math.max(maxHeight, py + ph);
		}

		ctx.canvas.height = ctx.canvas.width / maxWidth * maxHeight;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		var space=0; // space between panels + margin
		var ppL = (ctx.canvas.width  - space * 2) / maxWidth; //pixels per led

		ctx.lineWidth = 1;
		ctx.strokeStyle="yellow";
		ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height); // add space between panels

		for (let p=0; p<gId("panels").children.length; p++) {
			var px = parseInt(Sf[`P${p}X`].value); //first led x
			var py = parseInt(Sf[`P${p}Y`].value); //first led y
			var pw = parseInt(Sf[`P${p}W`].value); //width
			var ph = parseInt(Sf[`P${p}H`].value); //height

			var pb = Sf[`P${p}B`].value == "1"; //bottom
			var pr = Sf[`P${p}R`].value == "1"; //right
			var pv = Sf[`P${p}V`].value == "1"; //vertical
			var ps = Sf[`P${p}S`].checked; //serpentine

			var topLeftX = px*ppL + space; //left margin
			var topLeftY = py*ppL + space; //top margin

			ctx.lineWidth = 3;
			ctx.strokeStyle="white";
			ctx.strokeRect(topLeftX, topLeftY, pw*ppL, ph*ppL); // add space between panels

			var lnX;
			var lnY;

			//find start led
			if (pb) //bottom
				lnY = topLeftY + ph*ppL - ppL/2;
			else //top
				lnY = topLeftY + ppL/2;
			if (pr) //right
				lnX = topLeftX + pw*ppL - ppL/2;
			else //left
				lnX = topLeftX + ppL/2;

			//first led
			ctx.fillStyle = "green";
			ctx.beginPath();
			ctx.arc(lnX, lnY, ppL*0.5, 0, 2 * Math.PI);
			ctx.fill();

			//start line
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(lnX, lnY);

			var longLineLength = (pv?ph:pw)*ppL - ppL;
			for (let ln=0; ln<(pv?pw:ph); ln++) { //loop over panelwidth (or height of vertical?)

				var serpLine = ps && ln%2!=0; //serp: turn around if even line

				if (pv) //if vertical
					lnY += (pb?-1:1) * longLineLength * (serpLine?-1:1); //if vertical change the Y
				else
					lnX += (pr?-1:1) * longLineLength * (serpLine?-1:1); //if horizontal change the X

				ctx.lineTo(lnX, lnY); //draw the long line

				if (ln<(pv?pw:ph)-1) { //not the last
					//find the small line end point
					if (pv) //vertical
						lnX += (pr?-1:1) * ppL;
					else //horizontal
						lnY += (pb?-1:1) * ppL;

					//if serpentine go next else go down
					if (ps) { //serpentine
						ctx.lineTo(lnX, lnY); //draw the serpentine line
					} else { 
						//find the other end of the long line
						if (pv) //vertical
							lnY += (pb?1:-1) * longLineLength * (serpLine?-1:1); //min as we go back
						else //horizontal
							lnX += (pr?1:-1) * longLineLength * (serpLine?-1:1);
						ctx.moveTo(lnX, lnY); //move to the start point of the next long line
					}
				}
			}
			ctx.stroke();

			//last led
			ctx.fillStyle = "red";
			ctx.beginPath();
			ctx.arc(lnX, lnY, ppL*0.5, 0, 2 * Math.PI);
			ctx.fill();

			ctx.font = '40px Arial'; 
			ctx.fillStyle = "orange";
			ctx.fillText(p, topLeftX + pw/2*ppL - 10, topLeftY + ph/2*ppL + 10);
		}
		gId("MD").innerHTML = "Matrix Dimensions (W*H=LC): " + maxWidth + " x " + maxHeight + " = " + maxWidth * maxHeight;
	}
	</script>
</head>
<body>
	<form id="form_s" name="Sf" method="post">
	<div class="toprow">
		<!-- <div class="helpB"><button type="button" onclick="H('features/2D')">?</button></div> -->
		<button type="button" onclick="B()">Quay lại</button><button type="button" onclick="fS()">Lưu cấu hình</button><hr>
	</div>
	<style>
	.neon-section {
		/* background: #0a0a0f; */
		padding: 20px;
		border-radius: 12px;
		border: 1px solid #222;
		box-shadow: 0 0 20px rgba(0, 255, 255, 0.05),
					0 0 30px rgba(255, 0, 150, 0.05);
		color: #e0e0e0;
		font-family: "Segoe UI", sans-serif;
	}

	.neon-title {
		font-size: 22px;
		font-weight: 700;
		margin-bottom: 10px;
		color: #ff2fbf;
		text-shadow: 0 0 8px #ff2fbf, 0 0 15px #ff2fbf;
	}

	.neon-section p {
		color: #ccc;
		margin: 6px 0;
	}

	.neon-label {
		display: block;
		margin-top: 14px;
		margin-bottom: 6px;
		font-size: 15px;
		font-weight: 500;
		color: #00eaff;
		text-shadow: 0 0 6px #00eaff;
	}

	.neon-select {
		background: #111;
		color: #fff;
		border: 1px solid #ff2fbf;
		padding: 8px 12px;
		border-radius: 6px;
		font-size: 14px;
		cursor: pointer;
		outline: none;
		transition: 0.25s;
		box-shadow: 0 0 8px rgba(255, 0, 200, 0.4);
	}

	.neon-select:hover {
		border-color: #00eaff;
		box-shadow: 0 0 12px #00eaff, 0 0 20px rgba(0, 255, 255, 0.4);
	}

	.neon-select option {
		background: #0f0f13;
		color: #fff;
	}
	</style>

	<div class="neon-section">
	<h2>Cài đặt LED 2D</h2>

	<p>Nếu bạn đang sử dụng ma trận LED 2D (LED panel), hãy cấu hình tại đây.</p>
	<p>Nếu bạn điều khiển hiệu ứng qua <b>xLights</b>, bạn có thể bỏ qua mục này để mặc định <b>"Dải LED 1D"</b>.</p>

	<label for="somp" class="neon-label">Chế độ hiển thị:</label>

	<select id="somp" name="SOMP" class="neon-select"
			onchange="resetPanels(); addPanels(); UI();">
		<option value="0">Dải LED 1D</option>
		<option value="1">Ma trận LED 2D</option>
	</select>
	</div>

	<div id="mpdiv" style="display:none;">
		<hr class="sml">
		<h3>Trình tạo Ma trận <button type="button" id="expGen" onclick="expand(this,gId('mxGen'));">&gt;</button></h3>
		<div id="mxGen" style="display:none;">
			Kích thước bảng (Rộng x Cao): <input name="PW" type="number" min="1" max="128" value="8"> x <input name="PH" type="number" min="1" max="128" value="8"><br>
			Số bảng ngang: <input name="MPH" type="number" min="1" max="8" value="1">
			Số bảng dọc: <input name="MPV" type="number" min="1" max="8" value="1"><br>
			Bảng đầu tiên: <select name="PB">
				<option value="0">Trên</option>
				<option value="1">Dưới</option>
			</select><select name="PR">
				<option value="0">Trái</option>
				<option value="1">Phải</option>
			</select><br>
			Hướng: <select name="PV">
				<option value="0">Ngang</option>
				<option value="1">Dọc</option>
			</select><br>
			Dạng rắn rít: <input type="checkbox" name="PS"><br>
			<i  class="warn">Nhấn Tạo sẽ tạo bố cục bảng LED với ma trận được sắp xếp sẵn.<br>Các giá trị phía trên <i>không</i> ảnh hưởng đến bố cục cuối cùng.<br>
				CẢNH BÁO: Bạn có thể cần cập nhật lại thông số từng bảng sau khi tạo.</i><br>
			<button type="button" onclick="gen();expand(gId('expGen'),gId('mxGen'));">Tạo</button>
		</div>
		<hr class="sml">
		<h3>Cài đặt bảng điều khiển</h3>
		Số lượng bảng: <input name="MPC" type="number" min="1" max="64" value="1" oninput="addPanels();UI();"><br>
		<i>Một ma trận được tạo thành từ 1 hoặc nhiều bảng LED vật lý.<br>
		Mỗi bảng có thể có kích thước khác nhau và/hoặc có hướng LED khác nhau và/hoặc điểm bắt đầu khác nhau và/hoặc bố cục khác nhau.</i><br>
		<h3>Bố cục bảng LED</h3>
		<div id="panels">
		</div>
		<hr class="sml">
		<div id="MD"></div>
		<canvas id="canvas"></canvas>
		<div id="json" >Tệp Gap: <input type="file" name="data" accept=".json"><button type="button" class="sml" onclick="uploadFile(d.Sf.data,'/2d-gaps.json')">Tải lên</button></div>
		<i>Lưu ý: Tệp Gap là tệp <b>.json</b> chứa một mảng với số phần tử bằng với kích thước ma trận.<br>
			Giá trị -1 nghĩa là pixel tại vị trí đó bị thiếu, giá trị 0 nghĩa là không bao giờ vẽ pixel đó, và 1 nghĩa là pixel bình thường.</i>
	</div>
	<hr>
	<button type="button" onclick="B()">Quay lại</button><button type="button" onclick="fS()">Lưu cấu hình</button>
	</form>
	<div id="toast"></div>
</body>
</html>
